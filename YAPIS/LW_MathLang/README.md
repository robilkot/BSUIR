# Компилятор языка MathLang

# Отчет по лабораторной работе

## Спецификация языка

Язык, описывающий математические вычисления
Встроенные типы: int, float
Операции: +, -, *, \, %, ^, ==, !=, <, >, <=, >=
Встроенные функции log, ln, sin, cos, tan, asin, acos, atan

Объявление переменных явное

Преобразование типов явное, например, a = (int) b

Оператор присваивания многоцелевой, например, a, b = c, d

Структуры, ограничивающие область видимости - подпрограммы

Маркер блочного оператора явный, например, { } или begin end

Условные операторы - двух вариантный оператор if-then-else

Перегрузка подпрограмм присутствует

Передача параметров в подпрограмму по ссылке

Допустимое место объявления подпрограмм в начале программы

Целевой код WAT, текстовое представление WASM

## Синтаксис объявления переменных и подпрограмм

Допускается объявление нескольких переменных за раз. Обязательно указание типа каждой переменной.

Допускается инициализация всех переменных одинаковым значением (если тип всех переменных совпадает),
либо иницилизация каждой переменной собственным значением.

Допускается инициализация любым выражением (в том числе константным).

Объявление переменных без инициализации не допускается.

Тип значения при инициализации должен соответствовать типу переменных. Неявные преобразования не допускаются.

```
float a = 0.0
float b, float c = 5.0 // Все две переменные инициализированы значением 5.0
float d, float e, float f = a  // Все три переменные инициализированы значением переменной a
float g, int h, bool e = 0.0, 2, true  // g = 0.0, h = 2, e = true
```

Объявление подпрограмм допускается в начале файла (обеспечено грамматикой).

Допускается перегрузка подпрограмм (одинаковое имя, разные параметры).

Все параметры в подпрограммы передаются по ссылке.

Синтаксис объявления подпрограммы и примеры: 
```
sub [имя] [ :([Список шаблонных аргументов]) ]? ([Список параметров]) { [Тело подпрограммы] }
```
```
sub computeWave(float x, float result) {
    result = sin(x) + 0.5 * sin(2. * x + 1.0)
}
sub computeWave(float x, float amplitude, float result) {
    result = amplitude * sin(x)
}
```
Возвращаемый тип пользовательских подпрограмм - void.

Стандартные подпрограммы могут возвращать другие типы. Математические подпрограммы (sin, cos, другие) возвращают float. Подпрограмма чтения (read) возвращает тип, указанный в шаблонном аргументе. Подпрограмма преобразования (cast) возвращает тип, указанный во втором шаблонном аргументе.

Допускается использование шаблонных аргументов (1 и более).

Не допускается использование выражений в качестве шаблонных аргументов.

В случае использования шаблонных подпрограмм семантическая проверка внутренних выражений производится по факту вызова при подстановке типов, не при определении подпрограмм.

Допускается явная реализация шаблонной подпрограммы, если присутствует шаблонное определение. При этом обязательно указание типов для всех шаблонных аргументов.

Допускается вызов шаблонных подпрограмм как с явным указанием шаблонных аргументов, так и с неявным (типы определяются автоматически из предоставленных аргументов).

Вызов стандартных подпрограмм преобразования и ввода требуют явного указания всех шаблонных аргументов (2 и 1 соответственно).

```
// Один шаблонный аргумент
sub pretty_write:(T)(T a)
{
    write("Something pretty\n")
    write(a)
    write("\n")
}

// Более одного шаблонного аргумента
sub double_template:(K, V)(K key, V value)
{
    V key_casted = cast:(K, V)(key) // Явное указание шаблонных аргументов при вызове
}


sub inner_initialization:(T)(T result)
{
    T intermediate_result = read:(T)() // Инициализация переменной шаблонного типа
    result = intermediate_result * cast:(float, T)(2.0)
}


// When defining templated subprogram, it is possible to manually provide custom implementation for specific types ...
sub explicit_implementation:(T)(T val)
{
    write("Arbitrary type")
    write(val)
    write("\n")
}

 // Явное определение шаблонной подпрограммы для конкретного типа
sub explicit_implementation:(int)(int val)
{
    write("Specifically for int!")
    write(val)
    write("\n")
}
```


## Синтаксис операций над данными

Значения переменных возможно изменять операцией присвоения выражения.

Выражением может выступать константа, ссылка на переменную, составное выражение, вызов подпрограммы.

Примеры операций над данными:
```
sub isRightTriangle(float a, float b, float c, bool result) {
	result = (a^2. + b^2. == c^2.) or (a^2. + c^2. == b^2.) or (b^2. + c^2. == a^2.) // Сложное математическое выражение со скобками
}

float cathetusA = read:(float)() // Вызов стандартной шаблонной подпрограммы
float cathetusB = read:(float)()

float area, float hypotenuse = 0.0 // Присвоение константы
area = cathetusA * cathetusB / 2.0 // Сложное математическое выражение

int roundedHypotenuse = cast:(float, int)(hypotenuse) // Преобразование
sub recursion:(T, K)(T val1, K val2)
{
    write(val1)
    write("\n")
    write(val2)
    write("\n")

    if (val2 > cast:(int, K)(5)) // Вызов подпрограмм с аргументами-литералами
    {
        return
    }

    val2 = val2 + cast:(int, K)(1)

    recursion(val2, val1) // Операции над шаблонными типами. Валидируются при подстановке типов (при вызове подпрограммы)
}

recursion(1.5, 2) 
```

## Синтаксис всех управляющих конструкций

### Оператор ветвления if-else

Требует выражения типа bool в условии

```
sub test(float c) {
    c = c * 2.0

    if(c > 100.0)
    {
        write("exiting recursion after c > 100\n")
        write(100500)
        write("\n")
    }
    else
    {
        test(c)
    }
}
```

### Оператор цикла for

Требует выражения типа bool в условии. Допускает не более одной операции в шаге.

```
for (float angle = 0.0; angle <= 6.28318; angle = angle + 0.1) {
    float result = 0.
	  computeWave(angle, result)

    write("sin(")
    write(angle)
    write(") = ")
    write(result)
    write("\n")
}
```


### Оператор цикла while

Требует выражения типа bool в условии

```
while(abs(sin(x) - target) > precision) {
    x = x + 0.01
    if (x > 10.0) { // Infinite loop guard
        break
    }
}
```

### Оператор цикла until

Требует выражения типа bool в условии

```
int x = 0
until(x == 10) {
  x = x + 1
	write(x)
}
```

Все циклы допускают применение в теле break, continue.

Допускается return в подпрограммах. Return в глобальной области видимости не допускается.

## Файл грамматики

Файл грамматики доступен по адресу grammar/MathLang.g4

## Перечень дополнительных классов

## Перечень генерируемых ошибок

Все семантические ошибки в удобном для чтения виде описаны в файле src/models/error_formatter.py

Список семантических ошибок:

- Нельзя присвоить значение типа {from_type} переменной типа {to_type}'
- Количество выражений (при присвоении) должно совпадать с количеством переменных или быть равным 1
- Символ {symbol} уже определен в этой области видимости
- Символ {symbol_id} не определен
- Символ {symbol_id} не определен в глобальной области видимости
- Подпрограмма {subprogram_id} не определена
- Глобальная переменная {symbol_id} вне подпрограммы не инициализирована
- Не найдено перегрузки {sub_name} с параметрами {params_string}
- Бинарный оператор '{operator}' применим только к {type_description}. Получены типы {left_type}, {right_type}"
- Унарный оператор '{operator}' применим только к {type_description}. Получен тип {actual_type}
- Оператор return может использоваться только внутри подпрограмм
- Операторы continue и break могут использоваться только внутри циклов
- Ожидался булев тип в условии. Получен {actual_type}
- Невозможно преобразовать {from_type} в {to_type}"
- Неиспользованный шаблонный аргумент {arg}"
- Требуется аргументов: {expected}. Получено аргументов: {actual}.
- Ожидался тип {expected}. Получен {actual}.
- Шаблонный аргумент {template_arg_type} не определен
- Тип {type} не определен
- Тип шаблонного аргумента {typ} не указан при явной реализации
- Явная реализация {sub_name} не допускается до шаблонного объявления подпрограммы
- Аргумент подпрограммы не соответствует типу шаблонного аргумента. Ожидался {expected}, получен {actual}
- Использование строк в качестве операндов не поддерживается языком

## Примеры работы компилятора

В папке samples представлены примеры исходного кода и полученных исполняемых файлов, а также промежуточного кода на WAT. 

Описания примеров:

- sample1: запрашивает у пользователя катеты прямоугольного треугольника, рассчитывает гипотенузу и другие характеристики треугольника

<img width="361" height="253" alt="image" src="https://github.com/user-attachments/assets/2fb0e94e-9186-4067-ab80-b38c88f68b3b" />

- sample2: рассчитывает значения составного тригонометрического выражения, аппроксимирует значение аргумента по значению функции с заданной точностью. Проверяет аксиому (sin^2(x) + cos^2(x) = 1)

<img width="419" height="711" alt="image" src="https://github.com/user-attachments/assets/f62d7289-af78-4096-a0e8-ede9e0bc80e1" />

- sample4: решает квадратное уравнение с заданными коэффициентами методом дискриминанта. Проверяет вычисленные решения.

<img width="789" height="77" alt="image" src="https://github.com/user-attachments/assets/062e6708-9a5a-4e8c-a7a0-c287a6f90d44" />

- sample6: рекурсивно возводит число в степень до достижения порога. Выводит сообщения при каждом вызове.
- 
<img width="789" height="185" alt="image" src="https://github.com/user-attachments/assets/6b9b380a-6336-4573-9ab3-696fcb39d95d" />

- sample7: шаблонная рекурсивная подпрограмма, с каждым вызовом инкрементирующая аргументы, переданные по ссылке. Порядок аргументов с каждым вызовом меняется для проверки корректности разрешения шаблонов.

<img width="140" height="405" alt="image" src="https://github.com/user-attachments/assets/ae8b532c-31e1-4393-bd2d-19ef099bb495" />

- sample8: песочница, повторяет другие примеры
- samples_templates: песочница для шаблонных подпрограмм, содержит все виды ошибок и примеры использования шаблонов
- samples_templates_correct.ml: аналогично предыдущему, но без ошибок

<img width="291" height="407" alt="image" src="https://github.com/user-attachments/assets/ca6517c6-3c48-47de-a645-799a6baacf83" />



## Установка и запуск

В репозиторий залита зависимость wabt-1.0.39 для компиляции WAT в WASM. Для запуска на ОС кроме Linux необходимо вручную скачать нужную версию из репозитория разработчиков: https://github.com/WebAssembly/wabt/releases 

Установите зависимости для Python.
```
./setup.sh
```
Запустите toolchain на файле с кодом MathLang.
```
source .venv/bin/activate
python toolchain.py samples/sample1.ml
```
Toolchain сгенерирует исполняемые файлы на WASM + JS, а также промежуточный код на WAT.
В случае ошибок компиляция остановится, будут выведены сообщения об ошибках.

Для запуска исполняемых файлов рекомендуется использовать node.js. Для корректной работы ввода через терминал требуются зависимости.

Установите зависимости для JS.
```
npm install
```
Запустите сгенерированный исполняемый файл.
```
node samples/sample1.js
```

Готово!
